#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     shoulderJoint, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ramp,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightFrontPair, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftFrontPair, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightRear,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftRear,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    handJoint,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "..\..\includes\rdpartyrobotcdr-3.3.1\drivers\hitechnic-sensormux.h"
#include "..\..\includes\rdpartyrobotcdr-3.3.1\drivers\lego-light.h"
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

// Name the light sensors
const tMUXSensor right_light = msensor_S2_1;
const tMUXSensor middle_light = msensor_S2_2;
const tMUXSensor left_light = msensor_S2_3;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																Global Variables
//
// Variables that will be used by the code from outside functions.
//
// Global Variables:
//
//		1. name: black_threshold
//			 description: the value of the color black
//		   function: values lower than this number are the black color of the wood under the scoring
//					board
//
//		2. name: white_threshold
//			 description: the value of the color white
//			 function: values higher than this number are the white color of the tape on the scoring
//					board
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int black_threshold = 30;
int white_threshold = 40;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{

	// Set light sensors to active

	LSsetActive(left_light);
	LSsetActive(middle_light);
	LSsetActive(right_light);

}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													Specific Functions for Light Sensor
//
/////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														Movement Functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void moveStraight(int power, int duration)
{
	motor[rightRear] = power;
	motor[rightFrontPair]= power;
	motor[leftRear] = power;
	motor[leftFrontPair] = power;
	wait1Msec(duration);
	motor[rightRear] = 0;
	motor[rightFrontPair] = 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
}

void move(int powerRight, int powerLeft, int duration)
{
	motor[rightRear] = powerRight;
	motor[rightFrontPair]= powerRight;
	motor[leftRear] = powerLeft;
	motor[leftFrontPair] = powerLeft;
	wait1Msec(duration);
	motor[rightRear] = 0;
	motor[rightFrontPair]= 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
}
void movearm (int power, int duration)
{
	motor[shoulderJoint] = power;
	wait1Msec(duration) ;
	motor[shoulderJoint] = 0;
}

void movehand (int position)
{
	servo[handJoint] = position;
}

void pack_hand()
{
	motor[shoulderJoint] = 40;
	wait1Msec(1600);
	servo[handJoint] = 60;
	wait1Msec(350);
	motor[shoulderJoint] = 0;
}

void allStop()
{
	motor[rightRear] = 0;
	motor[rightFrontPair]= 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
	motor[shoulderJoint] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation.
//
// This code will cause the robot to follow a white line from a starting position of perpendicular
// to the line.
//
// Steps:
//
//		1. Find the line
//				a. The robot will move forward until it first detects the line.
//
//		2. Turn 90 degrees
//				a. As the sensors are on the front of the robot, turning 90 degrees from when the sensors
//					 first find the line will not put the robot on that line.
//				b. After finding the line, the robot needs to move forward for a distance of half its length,
//					 and then turn 90 degrees.
//
//		3. Follow the line
//				a. The robot will move forward slowly, periodically checking that is still on the line.
//				b. The sensors will be configured such that the left one is always on black, the middle one is
//					 always on white, and the right one is always on black.
//				c. Using these configurations, corrections will be calculated based on the positions of all
//					 three sensors in regards to the white line.
//							1. Left on white, middle on white (or black), right on black: turn toward the left
//							2. Left on black, middle on white (or black), right on white: turn toward the right
//							3. Left on black, middle on white, right on black: move straight
//
//		4. More later...(continue following the line until a touch sensor is triggered)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();
	waitForStart(); // Wait for the beginning of autonomous phase.
	wait1Msec(100);

	//
	// Find the line
	//
	// Continue forward until the middle sensor detects the white line
	//

	while (LSvalNorm(middle_light) < white_threshold){
		moveStraight(-20,25);
	}

	//
	// Turn 90 degrees
	//
	// Move forward a little more and then turn until the middle sensor detects the white line
	//

	bool isLeft = false; // If this boolean is true, the 90 degree turn is toward the left

	moveStraight(-15,400);
	while (LSvalNorm(middle_light) < white_threshold){
		if (isLeft){
			move(-30,30,20);
		}
		else{
			move(30,-30,20);
		}
	}

	//
	// Follow the line
	//
	//	1. Left on white, middle on white (or black), right on black: turn toward the left
	//	2. Left on black, middle on white (or black), right on white: turn toward the right
	//	3. Left on black, middle on white, right on black: move straight
	//	4. Left on black, middle on black, right on black: lost...
	//

	int n = 0;
	int left_nrm;
	int middle_nrm;
	int right_nrm;

	while (n < 300){

		left_nrm = LSvalNorm(left_light);
		middle_nrm = LSvalNorm(middle_light);
		right_nrm = LSvalNorm(right_light);

		nxtDisplayCenteredTextLine(0, "%d", middle_nrm);

		if (left_nrm < black_threshold){
			// left sensor is black

			if (middle_nrm < black_threshold){
				// middle sensor is black

				if (right_nrm > black_threshold){
					// right sensor is white or gray
					// turn right

					move(0,-20,30);
					n += 1;
				}
				else{
					// right sensor is black
					// lost, so just turn right a lot

					move(20,-20,40);
				}
			}

			else{
				// middle sensor is not black

				if (middle_nrm > white_threshold){
					// middle sensor is white
					// assume right sensor is black
					// move straight

					moveStraight(-20,50);
					n += 5;
				}
				else{
					// middle sensor is gray
					// assume right sensor is gray
					// turn right

					move(0,-20,25);
					n += 1;
				}
			}
		}
		else{
			// left sensor is not black

			if (left_nrm > white_threshold){
				// left sensor is white
				// assume middle sensor is black
				// assume the right sensor is black too
				// turn left

				move(-20,0,30);
				n += 1;
			}
			else{
				// left sensor is gray
				// middle sensor is gray
				// assume right sensor is black
				// turn left

				move(-20,0,25);
				n += 1;
			}
		}
	}
	wait1Msec(2000);

	// More later....

	// back up a little and open arm
	moveStraight(20,700);
	motor[shoulderJoint] = -40;
	wait1Msec(700);
	servo[handJoint] = 180;
	motor[shoulderJoint] = -40;
	wait1Msec(900);

	while (true){
		return;
	}
}
