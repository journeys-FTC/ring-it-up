#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     eopd,           sensorAnalogActive)
#pragma config(Motor,  mtr_S1_C1_1,     shoulderJoint, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     ramp,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightFrontPair, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftFrontPair, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightRear,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftRear,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    handJoint,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																Global Variables
//
// Variables that will be used by the code from outside functions.
// Global Variables:
//		1. name: COMPASS_ZERO
//			 description: the original direction the robot is facing at the start of a game
//		   function: this will be utilized as the zero point for future reckonings as fields have a
//			 		high probability of all facing different compass directions.
//			 use: it will be originally set to -1, and then changed during initialization. If the value is
//					still -1, the compass reading will be discarded in favor of other sensors.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int COMPASS_ZERO;
int CURRENT_HEADING;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int nOldHeading = 999;

void initializeRobot()
{
	eraseDisplay();
	int i = 0;
  while (i < 400)
  {
    COMPASS_ZERO = SensorValue[compass];
    if (abs(COMPASS_ZERO - nOldHeading) > 1)
    {
      // Only update when changed to avoid LCD screen flicker
      nxtDisplayCenteredTextLine(0, "%d", COMPASS_ZERO);
      nOldHeading = COMPASS_ZERO;
    }
    i += 1;
  }
  //COMPASS_ZERO = SensorValue[compass];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													Specific Functions for Compass
//
// These functions serve the purpose of dealing with the circular nature of the compass sensor values.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int conversionHelper (int num){
	//
	// The idea for this function is that turning left or right requires subtracting or adding angles to the
	// current heading respectively (i.e. to turn 90 degrees right, add 90 degrees to the current heading).
	// With normal addition and subtraction, this causes issues as adding 1 to 359 becomes 0 as opposed to 360.
	// This function serves to translate those numbers outside of the range 0-359 into numbers inside its range
	// based on modular arithmetic.
	//
	// As an example, a -2 calculated angle would be processed into a 358 sensor value.
	//

	// num: the integer to be converted
	// 360 is used as that is the range of values collected by the compass sensor
	return (num%360);
}

int orientOnCurrentHeading (int cH, int heading){
	//
	// This function orients the value of cHeading to be 0, while those values to the left of it become
	// negative, and those to the right become positive.
	//

	// cH: CURRENT_HEADING/the heading to be oriented around
	// heading: the heading to orient

	if (cH <= 180){
		if (heading <= cH){
			return (-(cH-heading));
		}
		else{
			if (heading <= (cH+180)){
				return (heading - cH);
			}
			else{
				return (-((360-heading)+cH));
			}
		}
	}

	else{
		if ((heading <= cH) && (heading > conversionHelper(cH+180))){
			return (-(cH-heading));
		}
		else{
			if (heading > cH){
				return (heading-cH);
			}
			else{
				return ((360-cH)+heading);
			}
		}
	}
	return 999;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														Movement Functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void moveStraight(int power, int duration)
{
	motor[rightRear] = power;
	motor[rightFrontPair]= power;
	motor[leftRear] = power;
	motor[leftFrontPair] = power;
	wait1Msec(duration);
	motor[rightRear] = 0;
	motor[rightFrontPair] = 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
}

void move(int powerRight, int powerLeft, int duration)
{
	motor[rightRear] = powerRight;
	motor[rightFrontPair]= powerRight;
	motor[leftRear] = powerLeft;
	motor[leftFrontPair] = powerLeft;
	wait1Msec(duration);
	motor[rightRear] = 0;
	motor[rightFrontPair]= 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
}
void movearm (int power, int duration)
{
	motor[shoulderJoint] = power;
	wait1Msec(duration) ;
	motor[shoulderJoint] = 0;
}

void movehand (int position)
{
	servo[handJoint] = position;
}

void pack_hand()
{
	motor[shoulderJoint] = 40;
	wait1Msec(1600);
	servo[handJoint] = 60;
	wait1Msec(350);
	motor[shoulderJoint] = 0;
}

void allStop()
{
	motor[rightRear] = 0;
	motor[rightFrontPair]= 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
	motor[shoulderJoint] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// It will move forward (on the same compass heading) for some time.
// Then it will complete a 90 degree turn to the left, move for some
// time and stop.
//
// Steps:
//
//		1. Determine the current heading
//				a. The robot should have a COMPASS_ZERO which will become
//					 the current heading.
//
//		2. Follow the heading for some time
//				a. The value of COMPASS_ZERO will be set to currentHeading
//				b. The robot will move forward slowly, periodically checking
//					 to ensure it remains on course. This course will be determined
//					 by the value of CURRENT_HEADING, though it will actually be a
//					 range of potential values to follow: CURRENT_HEADING +/- 5.
//					 In other words, the robot will continue forward so long as its
//					 current sensor reading is equal to CURRENT_HEADING +/- 5.
//
//		3. Complete a 90 degree turn
//				a. The motors will be powered such that the robot turns left
//				b. This will continue periodically until the robot is facing
//					 90 degrees from COMPASS_ZERO
//
//		4. Follow new heading
//				a. The heading 90 degrees from COMPASS_ZERO will be set to
//					 CURRENT_HEADING
//				b. The robot will move forward slowly, periodically checking
//					 to ensure it remains on course.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();
	waitForStart(); // Wait for the beginning of autonomous phase.
	wait1Msec(100);

	//
	// Very first, the case in which the compass malfunctions and COMPASS_ZERO
	// has a value of -1 will be checked. In the case that it is -1, the program
	// will terminate.
	//

	if (COMPASS_ZERO == -1){

		return;
	}

	else{

		//
		// Determine current heading
		//
		CURRENT_HEADING = COMPASS_ZERO;

		//
		// Follow the heading
		//
		// The value of nTotalLoops will change the amount of time for which the
		// robot follows the heading. It is designed so that a turn to return to
		// the correct heading is counted as fewer toward nTotalLoops than a
		// straight movement.
		//
		// nCurrentHeading will be used to store the sensor value while in this
		// specific loop.
		//
		int n = 0;
		int nTotalLoops = 500;
		int nCurrentHeading;

		while (n < nTotalLoops){
			nCurrentHeading = SensorValue[compass];
			nxtDisplayCenteredTextLine(0, "%d", nCurrentHeading);

			if ((orientOnCurrentHeading(CURRENT_HEADING, nCurrentHeading) > -5) && (orientOnCurrentHeading(CURRENT_HEADING,nCurrentHeading) < 5)){
				// The case if the current sensor value falls within the correct range.
				moveStraight(-20,20);
				n += 5;
			}
			else if (orientOnCurrentHeading(CURRENT_HEADING, nCurrentHeading) < 0){
				// The case if the current sensor value is to the left of the correct range.
				// i.e. the robot needs to turn to the right.
				move(20,-20,10);
				n += 1;
			}
			else if (orientOnCurrentHeading(CURRENT_HEADING, nCurrentHeading) > 0){
				// The case if the current sensor value is to the right of the correct range.
				// i.e. the robot needs to turn to the left.
				move(-20,20,10);
				n += 1;
			}
		}

		wait1Msec(1000);

		//
		// Complete 90 degree turn
		//
		// The objective is to turn to the left until the compass heading is different
		// from the original by -90 degrees.
		//
		// To do this:
		//
		//		1. Calculate desired position to be -90 degrees when oriented on the current
		//			 heading.
		//
		//		2. Begin turning, periodically checking the heading based on the above
		//			 orientation
		//
		//		3. If the heading based on the above orientation is less than -90 degrees, turn
		//			 toward the right instead of the left.
		//

		int turnAngle = -90;
		int mGoalHeading = conversionHelper(CURRENT_HEADING + turnAngle);
		int mCurrentHeading = SensorValue[compass];

		int vmCurrentHeading;
		int vmGoalHeading = orientOnCurrentHeading(CURRENT_HEADING,mGoalHeading);

		while ((orientOnCurrentHeading(mGoalHeading, mCurrentHeading) < 0) || (orientOnCurrentHeading(mGoalHeading, mCurrentHeading) > 10)){
			nxtDisplayCenteredTextLine(0, "%d", mCurrentHeading);
			vmCurrentHeading = orientOnCurrentHeading(CURRENT_HEADING,mCurrentHeading);

			int mDuration = abs((vmGoalHeading-vmCurrentHeading)/5);
			if (mDuration < 5){
				mDuration = 5;
			}

			if (vmCurrentHeading > vmGoalHeading){
				move(-20,20,mDuration);
			}
			else if (vmCurrentHeading < vmGoalHeading) {
				move(20,-20,mDuration);
			}
			else{
				break;
			}
			mCurrentHeading = SensorValue[compass];
		}
	}

	while (true)
	{
		nxtDisplayCenteredTextLine(0, "%d", SensorValue[compass]);
	}
}
