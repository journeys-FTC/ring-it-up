#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     IRSEEKER,       sensorI2CCustom)
#pragma config(Sensor, S3,     COMPASS,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  mtr_S1_C1_1,     shoulderJoint, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     ramp,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     rightFrontPair, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftFrontPair, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightRear,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftRear,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    handJoint,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    irseekerServo,        tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "..\..\includes\rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																Global Variables
//
// Variables that will be used by the code from outside functions.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int COMPASS_ZERO;
int CURRENT_HEADING;
int SERVO_OPTIMAL_POS = 85; // This is the position at which the ir servo is at the correct angle
														// for turning to score rings.

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int nOldHeading = 999;

void initializeRobot()
{
	eraseDisplay();
	int i = 0;
  while (i < 400)
  {
    COMPASS_ZERO = SensorValue[COMPASS];
    if (abs(COMPASS_ZERO - nOldHeading) > 1)
    {
      // Only update when changed to avoid LCD screen flicker
      nxtDisplayCenteredTextLine(0, "%d", COMPASS_ZERO);
      nOldHeading = COMPASS_ZERO;
    }
    i += 1;
  }
  //COMPASS_ZERO = SensorValue[compass];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													Specific Functions for IRSensor
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int conversionHelper (int num){
	//
	// The idea for this function is that turning left or right requires subtracting or adding angles to the
	// current heading respectively (i.e. to turn 90 degrees right, add 90 degrees to the current heading).
	// With normal addition and subtraction, this causes issues as adding 1 to 359 becomes 0 as opposed to 360.
	// This function serves to translate those numbers outside of the range 0-359 into numbers inside its range
	// based on modular arithmetic.
	//
	// As an example, a -2 calculated angle would be processed into a 358 sensor value.
	//

	// num: the integer to be converted
	// 360 is used as that is the range of values collected by the compass sensor
	return (num%360);
}

int orientOnCurrentHeading (int cH, int heading){
	//
	// This function orients the value of cHeading to be 0, while those values to the left of it become
	// negative, and those to the right become positive.
	// It returns the value of "heading" in this orientation.
	//

	// cH: CURRENT_HEADING/the heading to be oriented around
	// heading: the heading to orient on

	if (cH <= 180){
		if (heading <= cH){
			return (-(cH-heading));
		}
		else{
			if (heading <= (cH+180)){
				return (heading - cH);
			}
			else{
				return (-((360-heading)+cH));
			}
		}
	}

	else{
		if ((heading <= cH) && (heading > conversionHelper(cH+180))){
			return (-(cH-heading));
		}
		else{
			if (heading > cH){
				return (heading-cH);
			}
			else{
				return ((360-cH)+heading);
			}
		}
	}
	return 999;
}

int findIR (){

	//
	// This function moves the servo with the IRSensor on it to find the strongest signal from the IRBeacon.
	// It returns the final position of the irServo.
	//

	//
	// Determines the general direction of the IRBeacon, and then positions the servo
	// at the lower limit of the 5 range (i.e. dir is on the edge of 5 and 6).
	//
	// 5 is straight ahead,
	// 1-4 are to the left,
	// 6-9 are to the right,
	// and 0 is broken. (well not really, but it means it couldn't find a signal
	//
	servoChangeRate[irseekerServo] = 5;
	int dir;
	int prevdir;
	dir = HTIRS2readACDir(IRSEEKER);
	writeDebugStreamLine("dir: %d", dir);
	prevdir = dir;
	while (dir <= 5){
		if ((ServoValue[irseekerServo] - 2) > 10){
			servo[irseekerServo] = ServoValue[irseekerServo] - 2;
			wait1Msec(50);
			dir = HTIRS2readACDir(IRSEEKER);
		}
		else{
			writeDebugStreamLine("servo tried to go too far toward 0");
			break;
		}
		if (dir != prevdir){
			prevdir = dir;
			writeDebugStreamLine("dir: %d", dir);
		}
	}
	while (dir > 5){
		if ((ServoValue[irseekerServo] + 2) < 245){
			servo[irseekerServo] = ServoValue[irseekerServo] + 2;
			wait1Msec(50);
			dir = HTIRS2readACDir(IRSEEKER);
		}
		else{
			writeDebugStreamLine("servo tried to go too far toward 255");
			break;
		}
		if (dir != prevdir){
			prevdir = dir;
			writeDebugStreamLine("dir: %d", dir);
		}
	}

	//
	// Fine tune using the signal strengths within each of the five sensors on the IRSensor
	//
	servoChangeRate[irseekerServo] = 1;
	int acS1, acS2, acS3, acS4, acS5 = 0;
	int maxSensor;
	int maxServo;
  HTIRS2readAllACStrength(IRSEEKER, acS1, acS2, acS3, acS4, acS5);

  maxSensor = acS5;
  maxServo = ServoValue[irseekerServo];
  while (dir == 5){
  	if ((ServoValue[irseekerServo] + 1) < 245){
			servo[irseekerServo] = ServoValue[irseekerServo] + 1;
			wait1Msec(20);
			dir = HTIRS2readACDir(IRSEEKER);
		}
	 	HTIRS2readAllACStrength(IRSEEKER, acS1, acS2, acS3, acS4, acS5);

	  if (acS5 > maxSensor){
	  	maxSensor = acS5;
	  	maxServo = ServoValue[irseekerServo];
	  }
	}
	servo[irseekerServo] = maxServo;
	writeDebugStreamLine("robot believes optimal position to be %d.", maxServo);
	return maxServo;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														Movement Functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void move(int powerRight, int powerLeft, int duration){
	// Sets the value of the right and left sides to the respective powers
	// Stops the motors after the duration

	motor[rightFrontPair] = powerRight;
	motor[rightRear] = powerRight;

	motor[leftFrontPair] = powerLeft;
	motor[leftRear] = powerLeft;

	wait1Msec(duration);

	motor[rightFrontPair] = 0;
	motor[rightRear] = 0;
	motor[leftFrontPair] = 0;
	motor[leftRear] = 0;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// Brief description: score on the rack using an IRSensor and a compass sensor. The IRSensor is mounted
// on a servo to provide an angle for the direction of the IRBeacon in relation to the orientation of
// the robot.
//
// Steps:
//
//		1. Drive forward slightly to clear the rings
//
//		2. Find the IRBeacon with the IRSensor
//				a. Determine the angle with relation to the orientation of the robot
//
//		3. Drive forward a little and then determine the angle of the IRBeacon again
//				a. Perform a sweep with the IRSensor to find the strongest value
//
//		4. Continue step 3 until the desired angle and the angle of the IRBeacon line up
//
//		5. Turn the desired angle to line the robot up with the scoring rack (45 degrees in this case)
//
//		6. Go score...
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	waitForStart();
	wait1Msec(20);
	int servoPosition;

	// Drive forward slightly to clear rings
	// move(-50,-50,500);

	// Find the IRBeacon with the IRSensor
	// From here on, the code is specialized toward the middle and far pegs (for now...)
	servoPosition = findIR();
}
