#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorHiTechnicTouchMux)
#pragma config(Motor,  mtr_S1_C1_1,     spear,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     shoulderJoint, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rightFrontPair, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     leftFrontPair, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightRear,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftRear,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    handJoint,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "..\includes\rdpartyrobotcdr-3.3.1\drivers\hitechnic-sensormux.h"
#include "..\includes\rdpartyrobotcdr-3.3.1\drivers\lego-light.h"
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

// Name the light sensors
const tMUXSensor right_light = msensor_S2_1;
const tMUXSensor middle_light = msensor_S2_2;
const tMUXSensor left_light = msensor_S2_3;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																Global Variables
//
// Variables that will be used by the code from outside functions.
//
// Global Variables:
//
//		1. name: black_threshold
//			 description: the value of the color black
//		   function: values lower than this number are the black color of the wood under the scoring
//					board
//
//		2. name: white_threshold
//			 description: the value of the color white
//			 function: values higher than this number are the white color of the tape on the scoring
//					board
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int black_threshold = 27;
int white_threshold = 38; // with long arm

// int white_threshold = 45;

int scoringHand = 130;
int packedHand = 40;

int deployedSpearEncoderVal = 10000;
int retractedSpearEncoderVal = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{

	// Set light sensors to active
	LSsetActive(left_light);
	LSsetActive(middle_light);
	LSsetActive(right_light);

	// Initialize the encoder
	// nMotorEncoder[shoulderJoint] = 0;
	nMotorEncoder[spear] = 0;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														Movement Functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void all_stop(){
	motor[rightFrontPair] = 0;
	motor[rightRear] = 0;
	motor[leftFrontPair] = 0;
	motor[leftRear] = 0;
	//motor[shoulderJoint] = 0;
	motor[spear] = 0;
}

void moveStraight(int power, int duration){
	motor[rightRear] = power;
	motor[rightFrontPair]= power;
	motor[leftRear] = power;
	motor[leftFrontPair] = power;
	wait1Msec(duration);
	motor[rightRear] = 0;
	motor[rightFrontPair] = 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
}

void move(int powerRight, int powerLeft, int duration){
	motor[rightRear] = powerRight;
	motor[rightFrontPair]= powerRight;
	motor[leftRear] = powerLeft;
	motor[leftFrontPair] = powerLeft;
	wait1Msec(duration);
	motor[rightRear] = 0;
	motor[rightFrontPair]= 0;
	motor[leftRear] = 0;
	motor[leftFrontPair] = 0;
}
//void movearm (int power, int duration){
//	motor[shoulderJoint] = power;
//	wait1Msec(duration) ;
//	motor[shoulderJoint] = 0;
//}

//void movehand (int position){
//	servo[handJoint] = position;
//}

//void fold_arm(bool isFold){
//	// if isFold is true, the arm will return to folded position
//	// otherwise it will deploy to scoring position

//	all_stop();
//	if (isFold){
//		servo[handJoint] = packedHand;
//		while (nMotorEncoder[shoulderJoint] < -100){
//			motor[shoulderJoint] = 30;
//		}
//		writeDebugStreamLine("arm is folded at: %d", nMotorEncoder[shoulderJoint]);
//		//motor[shoulderJoint] = 40;
//		//wait1Msec(1300);
//		//servo[handJoint] = 80;
//		//wait1Msec(350);
//		return;
//	}
//	else{
//		while (nMotorEncoder[shoulderJoint] > -2300){
//			motor[shoulderJoint] = -30;
//		}
//		motor[shoulderJoint] = 0;
//		writeDebugStreamLine("arm is halfway at: %d", nMotorEncoder[shoulderJoint]);
//		servo[handJoint] = scoringHand;

//		//motor[shoulderJoint] = -40;
//		//wait1Msec(700);
//		//writeDebugStreamLine("encoder is at 1: %d", nMotorEncoder[shoulderJoint]);
//		//servo[handJoint] = 180;

//		while (nMotorEncoder[shoulderJoint] > -4900){
//			motor[shoulderJoint] = -30;
//		}
//		motor[shoulderJoint] = 0;
//		writeDebugStreamLine("arm is extended at: %d", nMotorEncoder[shoulderJoint]);


//		//motor[shoulderJoint] = -40;
//		//wait1Msec(900);
//		//writeDebugStreamLine("encoder is at 2: %d", nMotorEncoder[shoulderJoint]);
//		//return;
//	}
//}

void deploySpear(bool isDeploy){
	// Deploys the spear if isDeploy is true (pushes it out)
	// Retracts the spear if isDeploy is false (pulls it in)
	//
	// Both are based on encoder values that assume the encoder was zeroed with the spear
	// retracted.

	if (isDeploy){
		while (nMotorEncoder[spear] < deployedSpearEncoderVal){
			motor[spear] = 20;
		}
		writeDebugStreamLine("spear encoder value: %d", nMotorEncoder[spear]);
	}
	else{
		while (nMotorEncoder[spear] > retractedSpearEncoderVal){
			motor[spear] = -20;
		}
	}
	motor[spear] = 0;
	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation.
//
// This code will cause the robot to follow a white line from a starting position of perpendicular
// to the line.
//
// Steps:
//
//		1. Move forward and turn
//				a. This is to get the robot from our side to the other side
//
//		2. Find the line
//				a. The robot will move forward until it first detects the line.
//
//		3. Turn 90 degrees
//				a. As the sensors are on the front of the robot, turning 90 degrees from when the sensors
//					 first find the line will not put the robot on that line.
//				b. After finding the line, the robot needs to move forward for a distance of half its length,
//					 and then turn 90 degrees.
//
//		4. Follow the line until touch sensor is triggered
//				a. The robot will move forward slowly, periodically checking that is still on the line.
//				b. The sensors will be configured such that the left one is always on black, the middle one is
//					 always on white, and the right one is always on black.
//				c. Using these configurations, corrections will be calculated based on the positions of all
//					 three sensors in regards to the white line.
//							1. Left on white, middle on white (or black), right on black: turn toward the left
//							2. Left on black, middle on white (or black), right on white: turn toward the right
//							3. Left on black, middle on white, right on black: move straight
//
//		4. More later...(continue following the line until a touch sensor is triggered)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();
	waitForStart(); // Wait for the beginning of autonomous phase.
	wait1Msec(100);

	//
	// Move to other side of field
	//

	moveStraight(-50,2100);
	move(50,-50,400);

	//
	// Find the line
	//
	// Continue forward until the middle sensor detects the white line
	//

	while (LSvalNorm(middle_light) < white_threshold){
	//while (LSvalNorm(middle_light) < 35){ // with long arm
		moveStraight(-20,25);
	}

	wait1Msec(1000);

	//
	// Turn 90 degrees
	//
	// Move forward a little more and then turn until the middle sensor detects the white line
	//

	bool isLeft = false; // If this boolean is true, the 90 degree turn is toward the left

	moveStraight(-15,700);
	//moveStraight(-15,1000); // with long arm

	deploySpear(true);

	while (LSvalNorm(middle_light) < white_threshold){
	//while (LSvalNorm(middle_light) < 35){ // with long arm
		if (isLeft){
			move(-20,20,20);
			//move(-30,30,20); // with long arm
		}
		else{
			move(15,-15,20);
			//move(30,-30,20); // with long arm
		}
	}

	//
	// Deploy the spear
	//


	//
	// Follow the line until touch sensor is triggered
	//
	//	1. Left on white, middle on white (or black), right on black: turn toward the left
	//	2. Left on black, middle on white (or black), right on white: turn toward the right
	//	3. Left on black, middle on white, right on black: move straight
	//	4. Left on black, middle on black, right on black: lost...
	//

	// Set up touch sensor variables
	int nButtonsMask;
	bool isTouch = false; // Boolean indicating if a touch sensor has been pressed.
												// If one has, this changes to true.


	// Set up light sensor variables
	int left_nrm;
	int middle_nrm;
	int right_nrm;

	while (isTouch == false){

		// Read light sensor values
		left_nrm = LSvalNorm(left_light);
		middle_nrm = LSvalNorm(middle_light);
		right_nrm = LSvalNorm(right_light);

		writeDebugStreamLine("left_nrm: %d", left_nrm);
		writeDebugStream("middle_nrm: %d, ", middle_nrm);
		writeDebugStream("right_nrm: %d, ", right_nrm);

		nxtDisplayCenteredTextLine(0, "%d", middle_nrm);

		if (left_nrm < black_threshold){
			// left sensor is black

			if (middle_nrm < black_threshold){
				// middle sensor is black

				if (right_nrm > black_threshold){
					// right sensor is white or gray
					// turn right

					move(0,-20,20);
				}
				else{
					// right sensor is black
					// lost, so just turn right a lot

					move(30,-30,40);
				}
			}

			else{
				// middle sensor is not black

				if (middle_nrm > white_threshold){
					// middle sensor is white
					// assume right sensor is black
					// move straight

					moveStraight(-20,30);
				}
				else{
					// middle sensor is gray
					// assume right sensor is gray
					// turn right

					move(0,-20,15);
				}
			}
		}
		else{
			// left sensor is not black

			if (left_nrm > white_threshold){
				// left sensor is white
				// assume middle sensor is black
				// assume the right sensor is black too
				// turn left

				move(-20,0,20);
			}
			else{
				// left sensor is gray
				// middle sensor is gray
				// assume right sensor is black
				// turn left

				move(-20,0,15);
			}
		}

		// Read touch sensor values
		nButtonsMask = SensorValue[S3];

		if (nButtonsMask & 0x01)
			isTouch = true;
		if (nButtonsMask & 0x02)
			isTouch = true;
	}
	wait1Msec(2000);

	//
	// More later....scoring stuff
	//
	//	1. Move backward a little
	//	2. Unfold arm
	//	3. Move forward a little
	//	4. Move arm down to score
	//	5. Back up
	//	6. Reset arm
	//	7. Move toward our rings?
	//


	// back up a little
	moveStraight(20,650);

	// unfold arm
	//fold_arm(false);

	// move forward a little
	moveStraight(-20,300);
	wait1Msec(1000);

	// move arm down
	//motor[shoulderJoint] = -20;
	//wait1Msec(400);
	//motor[shoulderJoint] = 0;

	// back up
	moveStraight(40,500);

	// reset arm
	//fold_arm(true);



	while (true){
		return;
	}
}
