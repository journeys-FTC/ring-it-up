#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     ,               sensorHiTechnicTouchMux)
#pragma config(Sensor, S4,     IRSEEKER,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C2_1,     shoulderJoint, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spear,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     rightFrontPair, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     leftFrontPair, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     rightRear,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     leftRear,      tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C1_1,    handJoint,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    irseekerServo,        tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "..\includes\rdpartyrobotcdr-3.3.1\drivers\hitechnic-irseeker-v2.h"
#include "..\includes\rdpartyrobotcdr-3.3.1\drivers\hitechnic-sensormux.h"
#include "..\includes\rdpartyrobotcdr-3.3.1\drivers\hitechnic-compass.h"

#include "..\includes\autoFunctions-rings.h"

// Set up compass sensor to the multiplexer
const tMUXSensor COMPASS = msensor_S2_4;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																Global Variables
//
// Variables that will be used by the code from outside functions.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int COMPASS_ZERO;
int CURRENT_HEADING;
int SERVO_OPTIMAL_POS = 85; // This is the position at which the ir servo is at the correct angle
														// for turning to score rings.
int COMPASS_TURN_ANGLE = -45;

int scoringHand = 100;
int packedHand = 205;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int nOldHeading = 999;

void initializeRobot()
{
	eraseDisplay();
	int i = 0;
  while (i < 400)
  {
    COMPASS_ZERO = SensorValue[COMPASS];
    if (abs(COMPASS_ZERO - nOldHeading) > 1)
    {
      // Only update when changed to avoid LCD screen flicker
      nxtDisplayCenteredTextLine(0, "%d", COMPASS_ZERO);
      nOldHeading = COMPASS_ZERO;
    }
    i += 1;
  }
  nMotorEncoder[shoulderJoint] = 0;
  //COMPASS_ZERO = SensorValue[compass];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													Specific Functions for IRSensor
//
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int conversionHelper (int num){
	//
	// The idea for this function is that turning left or right requires subtracting or adding angles to the
	// current heading respectively (i.e. to turn 90 degrees right, add 90 degrees to the current heading).
	// With normal addition and subtraction, this causes issues as adding 1 to 359 becomes 0 as opposed to 360.
	// This function serves to translate those numbers outside of the range 0-359 into numbers inside its range
	// based on modular arithmetic.
	//
	// As an example, a -2 calculated angle would be processed into a 358 sensor value.
	//

	// num: the integer to be converted
	// 360 is used as that is the range of values collected by the compass sensor
	return (num%360);
}

int orientOnCurrentHeading (int cH, int heading){
	//
	// This function orients the value of cHeading to be 0, while those values to the left of it become
	// negative, and those to the right become positive.
	// It returns the value of "heading" in this orientation.
	//

	// cH: CURRENT_HEADING/the heading to be oriented around
	// heading: the heading to orient on

	if (cH <= 180){
		if (heading <= cH){
			return (-(cH-heading));
		}
		else{
			if (heading <= (cH+180)){
				return (heading - cH);
			}
			else{
				return (-((360-heading)+cH));
			}
		}
	}

	else{
		if ((heading <= cH) && (heading > conversionHelper(cH+180))){
			return (-(cH-heading));
		}
		else{
			if (heading > cH){
				return (heading-cH);
			}
			else{
				return ((360-cH)+heading);
			}
		}
	}
	return 999;
}

int findIR (){

	//
	// This function moves the servo with the IRSensor on it to find the strongest signal from the IRBeacon.
	// It returns the final position of the irServo.
	//
	// First, it finds the general directs via a function of the IRSensor that returns a number from 0-9. The
	// sectioning is diagramed here:
	// http://www.usfirst.org/sites/default/files/uploadedFiles/Robotics_Programs/FTC/FTC_Documents/Using_the_IR_Seeker.pdf
	// Next, it determines the strongest signal within the section. Again, see the above link for a diagram.
	//
	// This is all achieved by mounting the IRSensor on a servo motor, and rotating the servo so the
	// IRSensor is facing the direction of the strongest signal strength.
	//

	//
	// Determines the general direction of the IRBeacon, and then positions the servo
	// at the lower limit of the 5 range (i.e. dir is on the edge of 5 and 6).
	//
	// 5 is straight ahead,
	// 1-4 are to the left,
	// 6-9 are to the right,
	// and 0 is broken. (well not really, but it means it couldn't find a signal
	//

	servoChangeRate[irseekerServo] = 5;
	int dir;
	int prevdir;
	dir = HTIRS2readACDir(IRSEEKER);
	writeDebugStreamLine("dir: %d", dir);
	prevdir = dir;
	while (dir <= 5){
		if ((ServoValue[irseekerServo] - 2) > 10){
			servo[irseekerServo] = ServoValue[irseekerServo] - 2;
			wait1Msec(50);
			dir = HTIRS2readACDir(IRSEEKER);
		}
		else{
			writeDebugStreamLine("servo tried to go too far toward 0");
			break;
		}
		if (dir != prevdir){
			prevdir = dir;
			writeDebugStreamLine("dir: %d", dir);
		}
	}
	while (dir > 5){
		if ((ServoValue[irseekerServo] + 2) < 245){
			servo[irseekerServo] = ServoValue[irseekerServo] + 2;
			wait1Msec(50);
			dir = HTIRS2readACDir(IRSEEKER);
		}
		else{
			writeDebugStreamLine("servo tried to go too far toward 255");
			break;
		}
		if (dir != prevdir){
			prevdir = dir;
			writeDebugStreamLine("dir: %d", dir);
		}
	}

	//
	// Fine tune using the signal strengths within each of the five sensors on the IRSensor
	//
	servoChangeRate[irseekerServo] = 1;
	int acS1, acS2, acS3, acS4, acS5 = 0;
	int maxSensor;
	int maxServo;
  HTIRS2readAllACStrength(IRSEEKER, acS1, acS2, acS3, acS4, acS5);

  maxSensor = acS5;
  maxServo = ServoValue[irseekerServo];
  while (dir == 5){
  	if ((ServoValue[irseekerServo] + 1) < 245){
			servo[irseekerServo] = ServoValue[irseekerServo] + 1;
			wait1Msec(20);
			dir = HTIRS2readACDir(IRSEEKER);
		}
	 	HTIRS2readAllACStrength(IRSEEKER, acS1, acS2, acS3, acS4, acS5);

	  if (acS5 > maxSensor){
	  	maxSensor = acS5;
	  	maxServo = ServoValue[irseekerServo];
	  }
	}
	servo[irseekerServo] = maxServo;
	writeDebugStreamLine("robot believes optimal position to be %d.", maxServo);
	return maxServo;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//														Movement Functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

/*
void move(int powerLeft, int powerRight, int duration){
	// Sets the value of the right and left sides to the respective powers
	// Stops the motors after the duration

	motor[rightFrontPair] = powerRight;
	motor[rightRear] = powerRight;

	motor[leftFrontPair] = powerLeft;
	motor[leftRear] = powerLeft;

	wait1Msec(duration);

	motor[rightFrontPair] = 0;
	motor[rightRear] = 0;
	motor[leftFrontPair] = 0;
	motor[leftRear] = 0;
}

void fold_arm(bool isFold){
	// if isFold is true, the arm will return to folded position
	// otherwise it will deploy to scoring position

	allStop();
	if (isFold){
		servo[handJoint] = packedHand;
		while (nMotorEncoder[shoulderJoint] < -100){
			motor[shoulderJoint] = 30;
		}
		writeDebugStreamLine("arm is folded at: %d", nMotorEncoder[shoulderJoint]);
		//motor[shoulderJoint] = 40;
		//wait1Msec(1300);
		//servo[handJoint] = 80;
		//wait1Msec(350);
		return;
	}
	else{
		while (nMotorEncoder[shoulderJoint] > -2300){
			motor[shoulderJoint] = -30;
		}
		motor[shoulderJoint] = 0;
		writeDebugStreamLine("arm is halfway at: %d", nMotorEncoder[shoulderJoint]);
		servo[handJoint] = scoringHand;

		//motor[shoulderJoint] = -40;
		//wait1Msec(700);
		//writeDebugStreamLine("encoder is at 1: %d", nMotorEncoder[shoulderJoint]);
		//servo[handJoint] = 180;

		while (nMotorEncoder[shoulderJoint] > -4900){
			motor[shoulderJoint] = -30;
		}
		motor[shoulderJoint] = 0;
		writeDebugStreamLine("arm is extended at: %d", nMotorEncoder[shoulderJoint]);


		//motor[shoulderJoint] = -40;
		//wait1Msec(900);
		//writeDebugStreamLine("encoder is at 2: %d", nMotorEncoder[shoulderJoint]);
		//return;
	}
}
*/

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// Brief description: score on the rack using an IRSensor and a compass sensor. The IRSensor is mounted
// on a servo to provide an angle for the direction of the IRBeacon in relation to the orientation of
// the robot.
//
// Steps:
//
//		1. Drive forward slightly to clear the rings
//
//		2. Find the IRBeacon with the IRSensor
//				a. Determine the angle with relation to the orientation of the robot
//
//		3. Drive forward a little and then determine the angle of the IRBeacon again
//				a. Perform a sweep with the IRSensor to find the strongest value
//
//		4. Continue step 3 until the desired angle and the angle of the IRBeacon line up
//
//		5. Turn the desired angle to line the robot up with the scoring rack (45 degrees in this case)
//
//		6. Go score...
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	waitForStart();
	wait1Msec(20);
	int servoPosition = -1;

	// Drive forward slightly to clear rings
	moveStraight(50,500);

	// Find the IRBeacon with the IRSensor
	servoPosition = findIR();

	//***** From here on, the code is specialized toward the middle and far pegs (for now...)

	while (servoPosition != SERVO_OPTIMAL_POS){
		// Continue moving along a straight line while the servo and its optimal position are not the same

		while (servoPosition > SERVO_OPTIMAL_POS){
			// Move forward while the servo's position is greater than optimal
			moveStraight(20,100);
			servoPosition = findIR();
		}
		while (servoPosition < SERVO_OPTIMAL_POS){
			// Move backward while the servo's position is less than optimal
			moveStraight(-20,100);
			servoPosition = findIR();
		}
	}

	// Now that the servo is at the optimal position, turn the robot 45 degrees with the compass
	int mGoalHeading = conversionHelper(CURRENT_HEADING + COMPASS_TURN_ANGLE);
	int mCurrentHeading = SensorValue[COMPASS];

	int vmCurrentHeading;
	int vmGoalHeading = orientOnCurrentHeading(CURRENT_HEADING,mGoalHeading);

	while ((orientOnCurrentHeading(mGoalHeading, mCurrentHeading) < 0) || (orientOnCurrentHeading(mGoalHeading, mCurrentHeading) > 10)){
		nxtDisplayCenteredTextLine(0, "%d", mCurrentHeading);
		vmCurrentHeading = orientOnCurrentHeading(CURRENT_HEADING,mCurrentHeading);

		int mDuration = abs((vmGoalHeading-vmCurrentHeading)/5);
		if (mDuration < 5){
			mDuration = 5;
		}

		if (vmCurrentHeading > vmGoalHeading){
			//turn left
			move(-20,20,mDuration);
		}
		else if (vmCurrentHeading < vmGoalHeading){
			//turn right
			move(20,-20,mDuration);
		}
		else{
			break;
		}
		mCurrentHeading = SensorValue[COMPASS];
	}

	// Deploy the spear
	deploySpear(true);

	// Move forward until the touch sensor is triggered
	// Set up touch sensor variables
	int nButtonsMask;
	bool isTouch = false; // Boolean indicating if a touch sensor has been pressed.
												// If one has, this changes to true.
	while (isTouch == false){
		setAllMotorVals(20);

		if (nButtonsMask & 0x01)
			isTouch = true;
		if (nButtonsMask & 0x02)
			isTouch = true;
	}
	allStop();

	// back up a little
	moveStraight(-20,650);

	//retract spear
	deploySpear(false);

	// unfold arm
	fold_arm(false);

	// move forward a little
	moveStraight(20,300);
	wait1Msec(1000);

	// move arm down
	motor[shoulderJoint] = -20;
	wait1Msec(400);
	motor[shoulderJoint] = 0;

	// back up
	moveStraight(-40,500);

	// reset arm
	fold_arm(true);

}
